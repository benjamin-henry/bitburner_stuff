{
  "/bin/grow.js": "/** @param {NS} ns */\nexport async function main(ns) {\n    const target = ns.args[0];\n    await ns.grow(target);\n}",
  "/bin/hack.js": "/** @param {NS} ns */\nexport async function main(ns) {\n    const target = ns.args[0];\n    await ns.hack(target);\n}",
  "/bin/weaken.js": "/** @param {NS} ns */\nexport async function main(ns) {\n    const target = ns.args[0];\n    await ns.weaken(target);\n}",
  "buyserver.js": "import {getServersList} from './utils'\n\nfunction isPowerOfTwo(x){\n    return x && (!(x&(x-1)));\n}\n\n\n/** @param {NS} ns */\nexport async function main(ns) {\n\tconst memory = ns.args[0];\n    const pservIndex = getServersList(ns).filter((s)=>s.includes(\"pserv\")).length\n    const hostname = \"pserv-\"+pservIndex;\n    let cost = 0;\n\n    if(!isPowerOfTwo(memory)) {\n        ns.tprint(\"Memory must be a power of 2.\")\n\t\treturn;\n    }\n\n\tcost = memory*55000; \n    const maxcost = ns.getServerMoneyAvailable('home');\n\n    if(cost > maxcost) {\n        ns.tprint(`Server is too expensive : ${Math.round(maxcost)} > ${cost}`)\n\t\treturn;\n    }\n\n    ns.purchaseServer(hostname, memory);\n    ns.tprint(`Server ${hostname}-${memory}Gb bought successfully.`)\n    return;\n}",
  "deploy.selfatk.js": "import {getServersList, getThreadCount} from './utils.js'\n\n/** @param {NS} ns */\nexport async function main(ns) {\n    const servers = getServersList(ns);\n    for (const server of servers) {\n        await ns.scp([\"/bin/grow.js\", \"/bin/weaken.js\", \"/bin/hack.js\"], \"home\", server);\n    }\n    while (true) {\n        for (const server of servers) {\n            if (server === \"home\")\n                continue;\n            if (ns.hasRootAccess(server)) {\n                const moneyThresh = ns.getServerMaxMoney(server) * 0.75;\n                if(moneyThresh===0) continue;\n                const securityThresh = ns.getServerMinSecurityLevel(server) + 5;\n                const canHack = ns.getHackingLevel() >= ns.getServerRequiredHackingLevel(server);\n                let availableThreads = getThreadCount(ns, server, 1.75);\n                if (ns.getServerSecurityLevel(server) > securityThresh) {\n                    if (availableThreads > 0 && canHack)\n                        ns.exec(\"bin/weaken.js\", server, availableThreads, server);\n                }\n                else if (ns.getServerMoneyAvailable(server) < moneyThresh && canHack) {\n                    if (availableThreads > 0)\n                        ns.exec(\"bin/grow.js\", server, availableThreads, server);\n                }\n                else {\n                    availableThreads = getThreadCount(ns, server, 1.7);\n                    if (availableThreads > 0 && canHack)\n                        ns.exec(\"bin/hack.js\", server, availableThreads, server);\n                }\n            }\n            else {\n                try {\n                    ns.brutessh(server);\n                    ns.ftpcrack(server);\n                    ns.relaysmtp(server);\n                    ns.httpworm(server);\n                    ns.sqlinject(server);\n                }\n                catch (e) {\n                    e;\n                }\n                try {\n                    ns.nuke(server);\n                }\n                catch (e) {\n                    e;\n                }\n            }\n            await ns.sleep(20);\n        }\n    }\n}",
  "early.js": "export async function main(ns) {\n    const target = ns.args[0];\n    const moneyThresh = ns.getServerMaxMoney(target) * 0.75;\n    const securityThresh = ns.getServerMinSecurityLevel(target) + 5;\n    ns.nuke(target);\n    while (true) {\n        if (ns.getServerSecurityLevel(target) > securityThresh) {\n            await ns.weaken(target);\n        }\n        else if (ns.getServerMoneyAvailable(target) < moneyThresh) {\n            await ns.grow(target);\n        }\n        else {\n            await ns.hack(target);\n        }\n    }\n}",
  "formulasutils.js": "/**\n * https://github.com/danielyxie/bitburner/blob/dev/src/Hacking.ts \n */\n\n export function calculateIntelligenceBonus(intelligence, weight = 1) {\n  return 1 + (weight * Math.pow(intelligence, 0.8)) / 600;\n}\n\nexport function calculateHackingChance(server, player) {\n  const hackFactor = 1.75;\n  const difficultyMult = (100 - server.hackDifficulty) / 100;\n  const skillMult = hackFactor * player.hacking;\n  const skillChance = (skillMult - server.requiredHackingSkill) / skillMult;\n  const chance =\n    skillChance * difficultyMult * player.hacking_chance_mult * calculateIntelligenceBonus(player.intelligence, 1);\n  if (chance > 1) {\n    return 1;\n  }\n  if (chance < 0) {\n    return 0;\n  }\n\n  return chance;\n}\n\nexport function calculateHackingTime(server, player) {\n  const difficultyMult = server.requiredHackingSkill * server.hackDifficulty;\n\n  const baseDiff = 500;\n  const baseSkill = 50;\n  const diffFactor = 2.5;\n  let skillFactor = diffFactor * difficultyMult + baseDiff;\n\n  skillFactor /= player.hacking + baseSkill;\n\n  const hackTimeMultiplier = 5;\n  const hackingTime =\n    (hackTimeMultiplier * skillFactor) /\n    (player.hacking_speed_mult * calculateIntelligenceBonus(player.intelligence, 1));\n\n  return hackingTime;\n}\n\nexport function calculateGrowTime(server, player) {\n  const growTimeMultiplier = 3.2; // Relative to hacking time multiplier. 16/5 = 3.2\n\n  return growTimeMultiplier * calculateHackingTime(server, player);\n}\n\nexport function calculateWeakenTime(server, player) {\n  const weakenTimeMultiplier = 4; // Relative to hacking time multiplier\n\n  return weakenTimeMultiplier * calculateHackingTime(server, player);\n}\n\nexport function calculateTimes(server, player) {\n  const difficultyMult = server.requiredHackingSkill * server.hackDifficulty;\n\n  const baseDiff = 500;\n  const baseSkill = 50;\n  const diffFactor = 2.5;\n  let skillFactor = diffFactor * difficultyMult + baseDiff;\n\n  skillFactor /= player.hacking + baseSkill;\n\n  const hackTimeMultiplier = 5;\n  const hackingTime =\n    (hackTimeMultiplier * skillFactor) /\n    (player.hacking_speed_mult * calculateIntelligenceBonus(player.intelligence, 1));\n  \n  const growTimeMultiplier = 3.2;\n  const weakenTimeMultiplier = 4;\n\n  return {\n    hTime: hackingTime,\n    wTime: weakenTimeMultiplier * hackingTime,\n    gTime: growTimeMultiplier * hackingTime\n  }\n}",
  "hacknode.js": "function getNodeInfo(ns, nodeIndex) {\n\tconst {name, level, ram, cores, cache, hashCapacity} = ns.hacknet.getNodeStats(nodeIndex);\n\tconst lvlUpgradeCost = ns.hacknet.getLevelUpgradeCost(nodeIndex, 1);\n\tconst ramUpgradeCost = ns.hacknet.getRamUpgradeCost(nodeIndex, 1);\n\tconst coreUpgradeCost = ns.hacknet.getCoreUpgradeCost(nodeIndex, 1);\n\treturn {\n\t\tname,\n\t\tlvl: level,\n\t\tlvlUpgradeCost,\n\t\tram,\n\t\tramUpgradeCost,\n\t\tcores,\n\t\tcoreUpgradeCost,\n\t\tcache,\n\t\thashCapacity,\n\t\tmaxLvl: level===200,\n\t\tmaxRam: ram===64,\n\t\tmaxCores: cores===16,\n\t\tmaxStats: level===200&&ram===64&&cores===16\n\t}\n}\n\n/** @param {NS} ns */\nexport async function main(ns) {\n\n\twhile(true) {\n\t\tconst numNodes = ns.hacknet.numNodes();\n\t\tconst moneyPercentage = .33\n\t\tfor(let n=0; n < numNodes; n++) {\n\t\t\tconst nodeInfo = getNodeInfo(ns, n);\n\t\t\tif(nodeInfo.lvlUpgradeCost < ns.getServerMoneyAvailable(\"home\")*moneyPercentage) ns.hacknet.upgradeLevel(n, 1);\n\t\t\tif(nodeInfo.ramUpgradeCost < ns.getServerMoneyAvailable(\"home\")*moneyPercentage) ns.hacknet.upgradeRam(n, 1);\n\t\t\tif(nodeInfo.coreUpgradeCost < ns.getServerMoneyAvailable(\"home\")*moneyPercentage) ns.hacknet.upgradeCore(n, 1);\n\t\t\tawait ns.sleep(1);\n\t\t\t\n\t\t}\n\t\tconst nodeCost = ns.hacknet.getPurchaseNodeCost();\n\t\tif(ns.getServerMoneyAvailable(\"home\")*moneyPercentage > nodeCost) {\n\t\t\tns.hacknet.purchaseNode()\n\t\t}\n\t\t\n\t\tawait ns.sleep(1);\n\t}\n}",
  "killall.js": "import { getServersList} from './utils.js'\n/** @param {NS} ns */\nexport async function main(ns) {\n\tconst servers = getServersList(ns).filter((s)=>s!=='home')\n\tservers.forEach((server)=>{\n\t\tns.tprint(server,\" \", ns.killall(server))\n\t})\n\tns.killall('home');\n}",
  "launchfleets.js": "import {getShips, getPotentialTargets, getRequirements, createFleets} from './utils.js'\n\n/** @param {NS} ns */\nexport async function main(ns) {\n\tns.disableLog(\"ALL\");\n\tconst filterHome = ns.args[0] ? ns.args[0] : \"yes\";\n\tconst attackDelay = 50;\n\tconst tick = 1000;\n\n\tconst virus = 'pirate.js';\n\tconst virusRam = ns.getScriptRam(virus);\n\n\tconst filename = 'attack-report.txt';\n\t\n\twhile(true) {\n\t\tconst ships = await getShips(ns, virus, virusRam, filterHome);\n\t\tconst availShips = Object.keys(ships).length;\n\t\tawait ns.write(filename, availShips + \" ships available\", \"w\");\n\t\tif(availShips === 0) {\n\t\t\tawait ns.sleep(tick);\n\t\t\tcontinue;\n\t\t}\n\t\tfor(const ship of Object.keys(availShips)) {\n\t\t\tconst ram = ships[ship];\n\t\t\tconst threads = Math.floor(ram / virusRam);\n\t\t\tawait ns.write(filename, \"\\n  -\" + ship + \": \" + threads + \" thread(s) available.\")\n\t\t}\n\t\tconst targets = getPotentialTargets(ns, \"revYield\");\n\t\tfor(const target of targets) {\n\t\t\tconst targetServer = target.server;\n\t\t\tns.print(\"Allocating ressources for: \" + targetServer);\n\t\t\tconst reqs = getRequirements(ns, targetServer, attackDelay);\n\t\t\tns.print(\"Creating fleets\");\n\t\t\tconst {fleets, assigned} = createFleets(ns, reqs, ships, virusRam);\n\t\t\tns.print(\"SETTING SAIL\");\n\t\t\tfor(const fleet of fleets) {\n\t\t\t\tconst action = fleet.action;\n\t\t\t\tfor(const ship of fleet.ships) {\n\t\t\t\t\tlet pid = 0;\n\t\t\t\t\twhile(ns.exec(virus, ship.server, ship.threads, action, targetServer, ship.delay, pid)) {\n\t\t\t\t\t\tpid++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tns.print(\"Updating Roster\");\n\t\t\tfor(let ship of Object.keys(assigned)) {\n\t\t\t\tconst usage = assigned[ship];\n\t\t\t\tif(usage.left <= 1) {\n\t\t\t\t\tdelete ships[ship]\n\t\t\t\t} else {\n\t\t\t\t\tships[ship]  = usage.left\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(Object.keys(ships).length === 0) {\n\t\t\t\tns.print(\"No more ships available\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tawait ns.sleep(tick);\n\t}\n}",
  "maxcash.js": "import {getThreadCount, getServersList, getHackableServers} from './utils.js'\n\n/** @param {NS} ns */\nexport async function main(ns) {\n\tns.disableLog(\"ALL\")\n\t\n\twhile(true) {\n        const servers = getServersList(ns);\n        for (const server of servers) {\n            await ns.scp([\"/bin/grow.js\", \"/bin/weaken.js\", \"/bin/hack.js\"], \"home\", server);\n        }\n\t\tconst targets = ns.args[0] ? [ns.args[0]] : getHackableServers(ns);\n\t\tfor(const server of servers) {\n\t\t\tif(server===\"home\") continue;\n\t\t\tfor(const target of targets) {\n\t\t\t\tif (ns.hasRootAccess(server)&&ns.hasRootAccess(target)) {\n\t\t\t\t\tconst moneyThresh = ns.getServerMaxMoney(target) * 0.75;\n\t\t\t\t\tconst securityThresh = ns.getServerMinSecurityLevel(target) + 3;\n\t\t\t\t\tlet availableThreads = getThreadCount(ns, server, 1.75);\n\t\t\t\t\tif (ns.getServerSecurityLevel(target) > securityThresh) {\n\t\t\t\t\t\tif (availableThreads > 0) {\n\t\t\t\t\t\t\t// ns.tprint(server + \" weakens \" +target);\n\t\t\t\t\t\t\tns.exec(\"bin/weaken.js\", server, availableThreads, target);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (ns.getServerMoneyAvailable(target) < moneyThresh) {\n\t\t\t\t\t\tif (availableThreads > 0) {\n\t\t\t\t\t\t\t// ns.tprint(server + \" weakens \" +target);\n\t\t\t\t\t\t\tns.exec(\"bin/grow.js\", server, availableThreads, target);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tavailableThreads = getThreadCount(ns, server, 1.7);\n\t\t\t\t\t\tif (availableThreads > 0) {\n\t\t\t\t\t\t\t// ns.tprint(server + \" hacks \" +target);\n\t\t\t\t\t\t\tns.exec(\"bin/hack.js\", server, availableThreads, target);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tns.brutessh(server);\n\t\t\t\t\t\tns.ftpcrack(server);\n\t\t\t\t\t\tns.relaysmtp(server);\n\t\t\t\t\t\tns.httpworm(server);\n\t\t\t\t\t\tns.sqlinject(server);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\te;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tns.nuke(server);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\te;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tawait ns.sleep(10);\n\t}\n}",
  "pirate.js": "/** @param {NS} ns */\nexport async function main(ns) {\n\tconst action = ns.args[0]\n\tconst target = ns.args[1]\n\tconst delay = ns.args[2]\n\tconst pid = ns.args[3]\n\n\tawait ns.sleep(delay);\n\n\tif(action===\"weaken\") {\n\t\tawait ns.weaken(target);\n\t} else if(action===\"grow\") {\n\t\tawait ns.grow(target);\n\t} else {\n\t\tawait ns.hack(target);\n\t}\n}",
  "powersof2.js": "/** @param {NS} ns */\nexport async function main(ns) {\n\tlet infos = []\n\tfor(let i=0; i<21;i++) {\n\t\tconst ram = Math.pow(2,i);\n\t\tconst cost = ram * 55000;\n\t\tconst money = ns.getServerMoneyAvailable(\"home\");\n\t\tconst canBuy = money > cost;\n\t\tconst remaining = canBuy ? money - cost : -1;\n\t\tinfos.push({\n\t\t\tram,\n\t\t\tcost,\n\t\t\tcanBuy,\n\t\t\tremaining\n\t\t})\n\t}\n\n\tlet output = \"\\n\"\n\tfor(const info of infos) {\n\t\tObject.entries(info).forEach(([k,v]) => {\n\t\t\toutput += `${k}: ${v}\\n`\n\t\t})\n\t\toutput += \"\\n\"\n\t}\n\tns.tprint(output)\n}",
  "searchserver.js": "/** @param {NS} ns **/\nexport async function main(ns) {\n\tconst s_target = ns.args[0];\n\tif (s_target == null) {\n\t\treturn ns.tprint('Returns path to the searched server. Usage: run search.js <some_server>');\n\t}\n\tlet search_result = await scanAll(ns, 'home', s_target);\n\tif (search_result !== null) {\n\t\tns.tprint(search_result.map((el) => {\n\t\t\treturn `connect ${el}; `\n\t\t}).reduce((prev, curr) => {\n\t\t\treturn prev + curr\n\t\t}));\n\t} else {\n\t\tns.tprint(`Server \"${s_target}\" was not found!`);\n\t}\n}\n\n/** @param {NS} ns **/\nasync function scanAll(ns, target = 'home', search_target = null, recursionCall = false) {\n\tconst targets = ns.scan(target);\n\tconst match = targets.find((elem) =>  {return RegExp(search_target).test(elem)});\n\tif (match) {\n\t\treturn [match]\n\t} else {\n\t\tfor (const [idx, target] of targets.entries()) {\n\t\t\tlet skip = false;\n\t\t\tif (recursionCall === true && idx === 0) {\n\t\t\t\tskip = true;\n\t\t\t}\n\t\t\tif (skip === false) {\n\t\t\t\tlet res = await scanAll(ns, target, search_target, true);\n\t\t\t\tif (res != null) {\n\t\t\t\t\treturn [target, ...res]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null\n\t}\n}",
  "utils.js": "import {\n    calculateHackingChance,\n    calculateTimes\n} from 'formulasutils.js'\n\n/** @param {NS} ns */\nexport function getServersList(ns, currentServer = \"home\", set = new Set()) {\n    let serverConnections = ns.scan(currentServer);\n    serverConnections = serverConnections.filter((s) => !set.has(s));\n    serverConnections.forEach((server) => {\n        set.add(server);\n        return getServersList(ns, server, set);\n    });\n    return Array.from(set.keys());\n}\n\n/** @param {NS} ns */\nexport function getThreadCount(ns, hostname, scriptRamUsage) {\n    const usableRam = ns.getServerMaxRam(hostname) - ns.getServerUsedRam(hostname);\n    return Math.floor(usableRam / scriptRamUsage);\n}\n\n/** @param {NS} ns */\nexport function getPenetrationPrograms(ns) {\n\treturn {\n\t    \"BruteSSH.exe\": ns.brutessh,\n        \"FTPCrack.exe\": ns.ftpcrack,\n        \"relaySMTP.exe\": ns.relaysmtp,\n        \"HTTPWorm.exe\": ns.httpworm,\n        \"SQLInject.exe\": ns.sqlinject\n\t}\n}\n\n/** @param {NS} ns */\nexport function hasEnoughHackSkill(ns, server) {\n\treturn ns.getHackingLevel() >= ns.getServerRequiredHackingLevel(server);\n}\n\n\n/** @param {NS} ns */\nexport function getPlayerPenetrationProgramsCount(ns) {\n    return ns.ls('home').filter(v => Object.keys(getPenetrationPrograms(ns)).includes(v)).length;\n}\n\n/** @param {NS} ns */\nexport function hasPlayerEnoughPenetrationPrograms(ns, server) {\n    return getPlayerPenetrationProgramsCount(ns) >= ns.getServerNumPortsRequired(server);\n}\n\n/** @param {NS} ns */\nexport function serverHasMoney(ns, server) {\n    return ns.getServerMaxMoney(server) > 0\n    //  && ns.getServerMoneyAvailable(server) > ns.getServerMaxMoney(server)*.75;\n}\n\n/** @param {NS} ns */\nexport function isHackable(ns, server) {\n    return !server.includes('home'||'pserv')&&hasEnoughHackSkill(ns, server)&&hasPlayerEnoughPenetrationPrograms(ns, server)&&serverHasMoney(ns,server);\n}\n\n/** @param {NS} ns */\nexport function getHackableServers(ns) {\n    return getServersList(ns).filter((server)=>isHackable(ns, server));\n}\n\n/** @param {NS} ns */\nexport function printServerInfo(ns, server) {\n    let money = ns.getServerMoneyAvailable(server);\n    if(money===0) money = 1;\n    const maxMoney = ns.getServerMaxMoney(server);\n    const minSec = ns.getServerMinSecurityLevel(server);\n    const sec = ns.getServerSecurityLevel(server); \n    ns.tprint(`\n    ${server}:\n     $_______: ${ns.nFormat(money, \"$0.000a\")} / ${ns.nFormat(maxMoney, \"$0.000a\")} ${(money/maxMoney).toFixed(2)*100}%\n     security: +${(sec - minSec).toFixed(2)}\n     hack____: ${ns.tFormat(ns.getHackTime(server))} (t=${Math.floor(ns.hackAnalyzeThreads(server, money))})\n     grow____: ${ns.tFormat(ns.getGrowTime(server))} (t=${Math.floor(ns.growthAnalyze(server, maxMoney*.75/money))})\n     weaken__: ${ns.tFormat(ns.getWeakenTime(server))} (t=${Math.floor(sec-minSec)*20})`);\n}\n\n/** @param {NS} ns */\nexport function getStrategy(ns, server) {\n\tconst moneyThresh = ns.getServerMaxMoney(server) * .75;\n\tconst secThresh = ns.getServerMinSecurityLevel + 5;\n\tlet type = '';\n\tlet seq = [];\n\tlet allocation = [];\n\n\tif(ns.getServerSecurityLevel(server) > secThresh) {\n\t\ttype = 'flog';\n\t\tseq = ['w','g'];\n\t\tallocation = [.6, .4];\n\t} else if(ns.getServerMoneyAvailable(server) < moneyThresh) {\n\t\ttype = 'nourish';\n\t\tseq = ['g','w'];\n\t\tallocation = [.6, .4];\n\t} else {\n\t\ttype = 'plunder';\n\t\tseq = ['h','w','g','w'];\n\t\tallocation = [.25,.25,.25,.25];\n\t}\n\treturn {\n\t\ttype,\n\t\tseq,\n\t\tallocation\n\t}\n}\n\nexport function computeRevYield(ns, maxMoney, money, hackChance, server, player, strategy) {\n    const numerator = maxMoney * hackChance;\n    const {hTime, wTime, gTime} = calculateTimes(ns.getServer(server), ns.getPlayer());\n    const maxThreads = getMaxThreads(ns, server);\n    const growThreads = maxThreads.grow;\n    const weakenThreads = maxThreads.weaken;\n    const hackThreads = maxThreads.hack;\n\n    let denominator = 0;\n    if(strategy.type=='flog') {\n        denominator = gTime*growThreads*+wTime*weakenThreads;\n        // denominator = gTime+wTime;\n    } else if(strategy.type=='nourish') {\n        denominator = gTime*growThreads*+wTime*weakenThreads;\n        // denominator = gTime+wTime;\n    } else {\n        denominator = gTime*growThreads+wTime*weakenThreads+hTime*hackThreads;\n        // denominator = gTime+wTime+hTime;        \n    }\n    denominator = denominator==0 ? 1e-9 : denominator;\n    return numerator/denominator;\n}\n\nexport function getServerInfo(ns, server) {\n    const maxMoney = ns.getServerMaxMoney(server);\n    const money = ns.getServerMoneyAvailable(server);\n    const moneyThresh = maxMoney *.75;\n    const reqHackLevel = ns.getServerRequiredHackingLevel(server);\n    const secLvl = ns.getServerSecurityLevel(server);\n    const minSecLvl = ns.getServerMinSecurityLevel(server);\n    const secThresh = minSecLvl + 5;\n    const reqPorts = ns.getServerNumPortsRequired(server);\n    const rootAcces = ns.hasRootAccess(server);\n    const maxRam = ns.getServerMaxRam(server);\n    const chance = calculateHackingChance(ns.getServer(server), ns.getPlayer());\n    const {hTime} = calculateTimes(server, ns.getPlayer())\n    const revYield = maxMoney * chance;\n    const strategy = getStrategy(ns, server);\n    // const revYield = computeRevYield(ns, maxMoney, money, chance, server, ns.getPlayer(), strategy);\n\n    let output = {\n        server,\n        maxMoney,\n        money,\n        moneyRatio: `${(money/maxMoney).toFixed(2)*100}%`,\n        moneyThresh,\n        reqHackLevel,\n        secLvl,\n        minSecLvl,\n        secThresh,\n        reqPorts,\n        rootAcces,\n        maxRam,\n        hackChance: chance,\n        revYield,\n    }\n    Object.entries(strategy).forEach(([k,v]) => {\n        output[`strategy.${k}`] = v\n    })\n    return output;\n}\n\n/** @param {NS} ns */\nexport function getComparator(ns, compareField=\"revYield\") {\n    return (a, b) => {\n        if(a[compareField] > b[compareField]) return -1;\n        if(a[compareField] < b[compareField]) return 1;\n        return 0; \n    }\n}\n\n/** @param {NS} ns */\nexport function getPotentialTargets(ns, compareField=\"revYield\") {\n\tconst hackableServers = getHackableServers(ns);\n\tconst details = hackableServers.map((server)=>{ return getServerInfo(ns, server)});\n\treturn details.sort(getComparator(ns, compareField))\t\n}\n\n/** @param {NS} ns */\nexport async function writeServersToFile(ns, serversDetails, filename) {\nlet lines = [];\n\tfor(const detail of serversDetails) {\n\t\tObject.entries(detail).forEach(([k,v])=> {lines.push(`${k}: ${v}`);})\n\t\tlines.push(\"\");\n\t}\n\tawait ns.write(filename, lines.join('\\n'), 'w');\n\tns.toast(`wrote targets to ${filename}`, \"info\", 3000);\n}\n\n/** @param {NS} ns */\nexport async function getShips(ns, virus, virusRam, filterHome=\"yes\") {\n    const allServers = getServersList(ns);\n    let servers = allServers.filter((server) => {\n        if(server===\"home\") return false;\n        return server.includes(\"pserv\") || (hasPlayerEnoughPenetrationPrograms(ns, server) && hasEnoughHackSkill(ns, server) && ns.getServerMaxRam(server)>=virusRam);\n    })\n    \n    for(const server of allServers) {\n        if(!ns.hasRootAccess(server)) {\n            try {\n                ns.brutessh(server);\n                ns.ftpcrack(server);\n                ns.relaysmtp(server);\n                ns.httpworm(server);\n                ns.sqlinject(server);\n            } catch (e) {\n                e;\n            }\n            try {\n                ns.nuke(server);\n            } catch (e) {\n                e;\n            }\n        }\n        await ns.scp(virus, server)\n    }\n\n    if(filterHome===\"no\") {\n        servers.push(\"home\")\n    }\n    \n    let acc = {};\n    servers.forEach((server) => {\n        acc[server] = ns.getServerMaxRam(server) - ns.getServerUsedRam(server);\n    });\n    \n    return acc;    \n}\n\n/** @param {NS} ns */\nexport function getDelayForActionSeq(ns, seq, server, attackDelay) {\n    const {wTime, hTime, gTime} = calculateTimes(ns.getServer(server), ns.getPlayer());\n    const timing = {\n        w: wTime,\n        g: gTime,\n        h: hTime\n    }\n    const baseTimes = seq.map((_, i) => i + (attackDelay*i));\n    const actionStart = seq.map((action, i) => {return baseTimes[i] - timing[action]})\n    const execStart = Math.min(...actionStart);\n    const delays = seq.map((_, i) => {\n        return Math.abs(execStart - actionStart[i]);\n    })\n    return delays;\n}\n\nexport function getMaxThreads(ns, server) {\n    const moneyHighThresh = ns.getServerMaxMoney(server) * .75;\n    const moneyLowThresh = ns.getServerMaxMoney(server) * .25;\n\tconst secThresh = ns.getServerMinSecurityLevel(server) + 5;\n    const money = ns.getServerMoneyAvailable(server);\n    let growThreads = 0;\n    if(money < 1) {\n        growThreads = 1;\n    } else {\n        const growMul = moneyHighThresh / money;\n        if(growMul >= 1) {\n            growThreads = Math.round(ns.growthAnalyze(server, growMul));\n        }\n    }\n    \n    const weakenEffect = ns.weakenAnalyze(1);\n    const weakenThread = Math.round(secThresh / weakenEffect);\n    const hackThreads = ns.hackAnalyzeThreads(server, moneyHighThresh-moneyLowThresh);\n    return {\n        grow: growThreads,\n        weaken: weakenThread,\n        hack: hackThreads\n    };\n}\n\n/** @param {NS} ns */\nexport function getRequirements(ns, server, attackDelay) {\n    const strategy = getStrategy(ns, server);\n    const delays = getDelayForActionSeq(ns, strategy.seq, server, attackDelay);\n    const maxThreads = getMaxThreads(ns, server);\n    return {\n        delays,\n        maxThreads,\n        strategy\n    };\n}\n\n\n/** @param {NS} ns */\nexport function getAllocation(ns, reqs, ships, virusRam) {\n    const totalThreads = Object.values(ships).reduce((sum, serverRam) => {\n        return sum += Math.floor(serverRam / virusRam);\n    }, 0);\n    const {maxThreads,strategy} = reqs;\n    let numWeaken = 0;\n    let numGrow = 0;\n    let numHack = 0;\n\n    if(maxThreads.total < totalThreads) {\n        numWeaken = maxThreads.weaken;\n        numGrow = maxTHreads.grow;\n        numHack = maxThreads.hack;\n    } else {\n        const { seq, allocation } = strategy;\n        for(let i = 0; i < seq.length; i++) {\n            const action = seq[i];\n            const portion = allocation[i];\n            if(action==='w') {\n                numWeaken = Math.floor(totalThreads*portion)\n            } else if(action==='g') {\n                numGrow = Math.floor(totalThreads*portion)\n            } else {\n                numHack = Math.floor(totalThreads*portion)\n            }\n        }\n    }\n    return {\n        numWeaken,\n        numGrow,\n        numHack\n    };\n}\n\n/** @param {NS} ns */\nexport function createFleets(ns, reqs, ships, virusRam) {\n    const {numWeaken,numGrow,numHack} = getAllocation(ns, reqs, ships, virusRam);\n    const contract = {\n        w: numWeaken,\n        g: numGrow,\n        h: numHack\n    };\n    return readyFleets(ns, reqs, contract, ships, virusRam);\n}\n\n/** @param {NS} ns */\nexport function readyFleets(ns, reqs, contract, ships, virusRam) {\n    const {strategy, delays} = reqs;\n    const { seq } = strategy;\n    const actions = {\n        w: 'weaken',\n        g: 'grow',\n        h: 'hack'\n    }\n\n    const sortedShips = Object.keys(ships).sort((a,b) => ships[b] - ships[a]);\n    let assigned = {};\n    let fleets = [];\n\n    for(let i=0; i<seq.length;i++) {\n        const delay = delays[i];\n        const sym = seq[i];\n        const action = actions[sym];\n        const maxThreads = contract[sym];\n        let fleet = {action,ships:[]};\n        let usedThreads = 0;\n\n        for(const server of sortedShips) {\n            if(usedThreads >= maxThreads) {\n                break;\n            } \n            if(assigned[server]) {\n                continue;\n            }\n            const ram = ships[server];\n            const maxExecThreads = Math.floor(ram / virusRam);\n            const newUsedThreads = usedThreads + maxExecThreads;\n            let threads = maxExecThreads;\n            if(newUsedThreads > maxThreads) {\n                threads = maxThreads - usedThreads;\n            }\n            usedThreads += threads;\n            if(threads > 0) {\n                assigned[server] = {\n                    used: threads,\n                    left: maxThreads - threads\n                };\n                fleet.ships.push({\n                    server,\n                    threads,\n                    delay\n                })\n            }\n        }\n        fleets.push(fleet);\n    }\n    return {\n        fleets,\n        assigned\n    }\n}\n\n/** @param {NS} ns */\nexport function crimes(ns) {\n    const crimesList = [\"heist\", \"assassination\", \"kidnap\", \"grand theft auto\", \"homicide\", \"larceny\", \"mug someone\", \"rob store\", \"shoplift\"];\n    const chance = crimesList.map((c) => {\n        return ns.getCrimeChance(c)\n    });\n    const stats = crimesList.map((c) => {\n        return ns.getCrimeStats(c)\n    })\n    ns.tprint(chance)\n    ns.tprint(stats)\n}"
}